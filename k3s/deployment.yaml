# kubectl apply -k .
apiVersion: apps/v1
kind: Deployment
metadata:
  name: datasource
spec:
  replicas: 1
  selector:
    matchLabels:
      component: datasource
  template:
    metadata:
      labels:
        component: datasource
    spec:
      containers:
      # Data source backend serving  metrics accessed by Grafana. This
      # datasource  is  accessed  from Grafana  at  http://datasource,
      # siehe Service  definition below. When in  development you will
      # probably  have  to  change  either  the  URL  or  the  Service
      # definition. This image is is always the same ...
      - name: datasource
        image: f0bec0d/datasource-clj@sha256:5cd58eac7f1f1111892c5c4a182170759825d8ddcf1dca2524084f2284a478c5
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
spec:
  replicas: 1
  selector:
    matchLabels:
      component: grafana
  template:
    metadata:
      labels:
        component: grafana
    spec:
      containers:
      # Grafana frontend for demo & devel:
      - name: grafana
        image: grafana/grafana:6.7.1
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 3000
        volumeMounts:
        - mountPath: "/etc/grafana/provisioning/datasources/"
          name: "datasources"
        - mountPath: "/etc/grafana/provisioning/dashboards/"
          name: "dashboard-providers"
        - mountPath: "/dashboards/"
          name: "dashboards"
        - mountPath: "/var/lib/grafana"
          name: "var-lib-grafana"
        # SimpleJson  Plugin  ist  not  installed  by  default.   This
        # environment setting  will trigger a download  from Internets
        # on container  start. Consider setting https_proxy  if plugin
        # fails to download:
        env:
        - name: "GF_INSTALL_PLUGINS"
          value: "grafana-simple-json-datasource"

      #
      # The Volume must be writable  by Grafana user.  With local path
      # *provisioner*  from  Rancher  the  volumes  (directories)  are
      # created with mode 0777 and root:root as owner. With local path
      # volumes  one would  need  an init  container  or manually  set
      # permissions like this:
      #
      #   mkdir -p /var/lib/k3s-volumes/var-lib-grafana/
      #   chown 472:472 /var/lib/k3s-volumes/var-lib-grafana/
      #   chmod 700 /var/lib/k3s-volumes/var-lib-grafana/
      #
      # # FIXME: what if the UID or GID change?
      # initContainers:
      # - name: "chown-n-chmod"
      #   image: "busybox:1.31"
      #   command: ["sh", "-c", "chown 472:472 /d && chmod 700 /d"]
      #   volumeMounts:
      #   - mountPath: "/d"
      #     name: "var-lib-grafana"

      # Volumes used by some or all containers of the Pod:
      volumes:
      - name: "datasources"
        configMap:
          name: "datasources"
      - name: "dashboard-providers"
        configMap:
          name: "dashboard-providers"
      - name: "dashboards"
        configMap:
          name: "dashboards"
      - name: "var-lib-grafana"
        persistentVolumeClaim:
          claimName: "grafana"
---
#
# There  is an  option do  define  Service without  selectors and  the
# corresponding Endpoints  separately. But if  you want to  point your
# Grafana to  such a service that  ist either a Cluster  Service or an
# external  service  you probably  better  separate  Grafana and  Data
# Source into Pods on their own.
#
# [1] https://kubernetes.io/docs/concepts/services-networking/service/
#
apiVersion: v1
kind: Service
metadata:
  name: grafana
spec:
  type: ClusterIP
  selector:
    component: grafana
  ports:
  - port: 80
    targetPort: 3000
---
#
# This service schould make the data source available to other Pods in
# the future:. Resolving  Services on ports other that  default HTTP &
# HTTPS ports would probably be more cumbersome.
#
apiVersion: v1
kind: Service
metadata:
  name: datasource
spec:
  type: ClusterIP
  selector:
    component: datasource
  ports:
  - port: 80
    targetPort: 8080
---
#
# We assume here that *.localhost resolves to the local machine.  Following
# URLs should be directed to Grafana.
#
#     http://grafana.localhost
#     https://grafana.localhost
#
apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: ingress
spec:
  rules:
  - host: grafana.localhost
    http:
      paths:
      - backend:
          serviceName: grafana
          servicePort: 80
---
# https://github.com/rancher/local-path-provisioner
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: grafana
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: local-path
  resources:
    requests:
      storage: 1Gi
...
